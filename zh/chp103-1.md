---
layout: post
title: 源码开放学ARM - Linux 字符设备驱动 - 字符设备驱动结构
---

# Linux 字符设备驱动 #
## 字符设备驱动结构

### 设备分类
	
#### 字符设备

一个字符( char ) 设备是一种可以当作一个字节流来访问存取的设备( 如同一个文件 ); 
一个字符驱动负责实现这种行为. 这样的驱动常常至少实现 open, close, read, 和 write 系统调用. 
文本控制台( /dev/console )和串口( /dev/ttyS0 及其类似的设备 )就是两个字符设备的例子, 因为它们很好地展现了流的抽象. 
字符设备通过文件系统结点来存取, 例如 /dev/tty1 和 /dev/lp0. 
在一个字符设备和一个普通文件之间唯一有关的不同就是, 你经常可以在普通文件中移来移去, 
但是大部分字符设备仅仅是数据通道, 你只能顺序存取.然而, 存在看起来象数据区的字符设备, 你可以在里面移来移去. 
例如, frame grabber 经常这样, 应用程序可以使用 mmap 或者 lseek 存取整个要求的图像.

#### 块设备

如同字符设备, 块设备通过位于 /dev 目录的文件系统结点来存取. 一个块设备(例如一个磁盘)应该是可以驻有一个文件系统的. 在大部分的 Unix 系统, 一个块设备只能处理这样的 I/O 操作, 传送一个或多个长度经常是 512 字节( 或一个更大的 2 的幂的数 )的整块. Linux, 相反, 允许应用程序读写一个块设备象一个字符设备一样 -- 它允许一次传送任意数目的字节. 结果就是, 块和字符设备的区别仅仅在内核在内部管理数据的方式上, 并且因此在内核/驱动的软件接口上不同. 如同一个字符设备, 每个块设备都通过一个文件系统结点被存取的, 它们之间的区别对用户是透明的. 块驱动和字符驱动相比, 与内核的接口完全不同.

#### 网络接口

任何网络事务都通过一个接口来进行, 就是说, 一个能够与其他主机交换数据的设备. 通常, 一个接口是一个硬件设备, 但是它也可能是一个纯粹的软件设备, 比如环回接口. 一个网络接口负责发送和接收数据报文, 在内核网络子系统的驱动下, 不必知道单个事务是如何映射到实际的被发送的报文上的. 很多网络连接( 特别那些使用 TCP 的)是面向流的, 但是网络设备却常常设计成处理报文的发送和接收. 一个网络驱动对单个连接一无所知; 它只处理报文.


### 字符设备驱动结构

字符设备是指发送或者接受数据按照字符方式进行，一般应用程序都通过设备文件来访问字符设备。

字符设备的驱动一般在 kernel-src/drivers/char 目录下。常见的字符设备有：鼠标，控制台，声卡，显示设备，touch panel，串口，并口等等。

我们可以在Linux源代码目录通过 make menuconfig来看到字符设备。

#### 字符设备管理

我们都知道应用程序是通过设备文件来访问字符设备的。那么设备文件通过什么标示来对应相关的驱动呢？这就是我们前面提到的设备号。

因为应用程序要与字符设备进行数据交互（read，write）。那么驱动还要提供读写函数。
并且要求将读写函数与设备号连接起来。这就是我们下面要讲的应用和驱动的关联。

#### 应用和驱动关联

在前面的课程我们谈到了设备文件, 给出了设备文件和设备号的概念。
这节课我们先看一个例子：

	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>

	#define filename "/dev/akae_c"

	int main (void)
	{
		int fd;
		char buf[10];
		int ret;
		
		fd = open (filename,O_RDWR);
		
		if (fd < 0)
		{
		    printf ("Open %s file error,please use sudo !",filename);
		    return -1;
		}

		ret = read (fd,buf,10);
		if (ret != 10)
		{
		    printf ("NOTICE: read %s file,get %d Bytes\n",filename,ret);
		}
	    
		ret = write (fd,buf,10);
		if (ret != 10)
		{
		    printf ("NOTICE: write %s file,get %d Bytes\n",filename,ret);
		}
		
		close (fd);
		
		return 0;
	}

从上例中我们可以看出：

	* 应用程序可以通过打开设备文件访问设备;
	* 可以通过read, write函数访问设备驱动;



[上一节](chp102-4.html)  |  [目录索引](../index.html)  |  [下一节](chp103-2.html)
